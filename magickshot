#!/bin/sh

main() {
    parse_opts "$@"

    dir=~/.local/share/magickshot/Screenshots
    title="`date +'%Y-%m-%d_%R:%S'`"
    dir2=$dir/import-$title.png
    mon="`randr | cut -d ' ' -f 3`"

    if [ -n "$help" ]; then
	help
    elif [ -n "$selection" -a -n "$window" ]; then
	screenshot -window `xdotool selectwindow`
    elif [ -n "$selection" ]; then
	xdotool mousemove_relative 1 0 ; xdotool mousemove_relative -- -1 0
	screenshot
    elif [ -n "$window" ]; then
	if [ -n "$2" ]; then
	    screenshot -window "$2"
	else
	    screenshot -window `xdotool getactivewindow`
	fi
    elif [ -n "$monitor" ]; then
	screenshot -window root && magick -extract $mon $dir2 $dir2
    elif [ -n "$display" ]; then
	screenshot -window root
    elif [ $# -eq 0 ]; then
	screenshot -window root && magick -extract $mon $dir2 $dir2
    else
	help
    fi
}

pl() {
    [ -z $PLAYER ] && PLAYER="mpv"
    setsid $PLAYER --really-quiet --pause=no --keep-open=no "$@" &>/dev/null
}

sound() {
    sound_dir=/usr/share/sounds/deepin/stereo

    if [ -d $sound_dir ]; then
	sound_1=$sound_dir/camera-shutter.wav
	sound_2=$sound_dir/dialog-error.wav

	pl $sound_1 || pl $sound_2
    fi
}

screenshot() { import "$@" $dir2 && sound; }

randr() { xrandr | grep ' connected' | sed 's/ primary//g' | tail -$(expr $(printmon) + 1) | head -1; }

help() {
    printf "Usage:	magickshot [options]

Options:
 -s|--selection │ Take a screenshot of the selection
 -w|--window    │ Take a screenshot of the specified window (default is focused window)
 -m|--monitor   │ Take a screenshot of the focused monitor
 -d|--display   │ Take a screenshot of the entire display
 -h|--help	│ Print this help message and exit

Use both the selection and window arguments at the same time and you will be able to use the cursor to select a specific window to take a screenshot of.
"
}

parse_opts() {
    die() { echo "$*" >&2; exit 2; }  # complain to STDERR and exit with error
    needs_arg() { [ -z "$OPTARG" ] && die "No arg for --$OPT option"; }

    while getopts hswmd-: OPT; do
	# support long options: https://stackoverflow.com/a/28466267/519360
	if [ "$OPT" = "-" ]; then   # long option: reformulate OPT and OPTARG
	    OPT="${OPTARG%%=*}"       # extract long option name
	    OPTARG="${OPTARG#$OPT}"   # extract long option argument (may be empty)
	    OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
	fi
	case "$OPT" in
	    h | help)     	help=1 ;;
	    s | selection)	selection=1 ;;
	    w | window)		window=1 ;;
	    m | monitor)	monitor=1 ;;
	    d | display)	display=1 ;;
	    ??*)          	die "Illegal option --$OPT" ;;  # bad long option
	    ?)            	exit 2 ;;  # bad short option (error reported via getopts)
	esac
    done
    shift $((OPTIND-1)) # remove parsed options and args from $@ list
}

main "$@"
